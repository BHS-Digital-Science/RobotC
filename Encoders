#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                              - PoE Robotics Challenge #3 (Encoders) -                              *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program instructs the robot to move along a given path and place a cone in a box.	      		*|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'rightMotor' (port 10) in the "Motors and Sensors Setup" is needed with the       *|
|*        "Squarebot" model, but may not be needed for all robot configurations.                      *|
|*    2)  Whichever encoder is being used for feedback should be cleared just before it starts        *|
|*        counting by using the "SensorValue(encoder) = 0;".  This helps ensure consistancy.          *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor   - Port 10   rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor   - Port 1    leftMotor           VEX 3-wire module     Left side motor                   *|
|*    Digital - Port 1,2  rightEncoder        VEX Shaft Encoder     Right side                        *|
|*    Digital - Port 3,4  leftEncoder         VEX Shaft Encoder     Left side                         *|
\*----------------------------------------------------------------------------------------------------*/


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
int moveStraight(int ticks, int maxSpd, int leftMin, int rightMin){

/*	The moveStraight() function moves the robot "ticks" number
	of times at the "maxSpd" speed value. It straightens using the "leftMin"
	and "rightMin" speed values.					*/

  	//Clear Encoders
  	SensorValue[rightEncoder] = 0;
  	SensorValue[leftEncoder] = 0;

  	while(SensorValue[leftEncoder] < ticks){  // While less than "ticks" rotations on the leftEncoder...

  		//...Auto Straightening
    	if(SensorValue[leftEncoder] > SensorValue[rightEncoder]){ //right motor = max speed, left motor = min speed

    		motor[leftMotor] = leftMin;
    		motor[rightMotor] = maxSpd;

  		}else if(SensorValue[leftEncoder] < SensorValue[rightEncoder]){	//left motor = max speed, right motor = min speed

  	  	motor[leftMotor] = maxSpd;
    		motor[rightMotor] = rightMin;

  		}else{

  		motor[leftMotor] = maxSpd;	//both max speed
    		motor[rightMotor] = maxSpd;

  		}
  	}

  	motor[leftMotor] = 0;
    motor[rightMotor] = 0;
    wait1Msec(500);
    //waitUntil(vexRT[Btn7D]==1);
    return 1;

}

int turnRight(int ticks, int maxSpd, int leftMin, int rightMin){
/*	The turnRight() function turns the robot to the right "ticks" number
	of times at the "maxSpd" speed value. It straightens by using the "leftMin"
	and "rightMin" speed values as well as by comparing absolute encoder values.		*/

	SensorValue[rightEncoder] = 0;
  	SensorValue[leftEncoder] = 0;

  	while(SensorValue[leftEncoder] < ticks){

  		if(fabs(SensorValue[leftEncoder]) > fabs(SensorValue[rightEncoder])){

  			motor[leftMotor] = leftMin;
  			motor[rightMotor] = -maxSpd;

  		}else if(fabs(SensorValue[leftEncoder]) < fabs(SensorValue[rightEncoder])){

  			motor[leftMotor] = maxSpd;
  			motor[rightMotor] = -rightMin;

  		}else{

  			motor[leftMotor] = maxSpd;
  			motor[rightMotor] = -maxSpd;

  		}

  	}

  	motor[leftMotor] = 0;
    motor[rightMotor] = 0;
		wait1Msec(500);
		//waitUntil(vexRT[Btn7D]==1);
		return 1;
}


int clawOn(int spd){	//turns the claw motor on with the indicated speed value, "spd". Doesn't turn off.

	motor[clawMotor] = spd;
	return 1;

}

int clawOff(){	//simply turns off the claw motor.

	motor[clawMotor] = 0;
	return 1;

}

int moveArm(int spd, int ms){	//turns the arm motor on with the indicated speed value, "spd". It turns off after
				// "ms" miliseconds.

	motor[armMotor] = spd;
	wait1Msec(ms);
	motor[armMotor] = 10;
	return 1;

}

task main()
{
	while(true){
     //=======================================================================================================
  	waitUntil(vexRT[Btn7D]==1);  // Remote start for first autonomous part
 		waitUntil(clawOn(63)==1);
  	waitUntil(moveStraight(3295,80,40,70));     //<---
  	waitUntil(turnRight(305,80,45,70)==1);      //<---
		waitUntil(moveStraight(1120,80,40,70)==1);      //<---
		waitUntil(turnRight(305,80,43,70)==1);     //<--- the sequence for the first autonomous part
		waitUntil(moveStraight(1850,80,40,70)==1);      //<---
		waitUntil(turnRight(305,80,45,70)==1);       //<---
		waitUntil(moveStraight(465,80,40,70)==1);      //<---
		//=======================================================================================================
		waitUntil(vexRT[Btn7D]==1);  // Remote start for second autonomous part
		waitUntil(turnRight(270,80,45,70)==1);   //<---
		//waitUntil(clawOn(63)==1);		   //<---
		//wait1Msec(500);				   //<---
		//waitUntil(clawOff()==1);		   //<---
		waitUntil(moveArm(70,350)==1);
		waitUntil(moveStraight(400,80,40,70));  
		waitUntil(clawOn(-63)==1);
		wait1Msec(1000);
		//waitUntil(moveStraight(500,127,52,123)==1);
		waitUntil(moveArm(90,350)==1);
		waitUntil(turnRight(22,80,45,70)==1); 
		waitUntil(moveStraight(500,80,40,70));  
	   //<---
		//waitUntil(clawOn(-63)==1);		   //<--- the sequence for the second autonomous part
			   //<---
		//waitUntil(moveStraight(544,127,52,123)==1);   //<---
		waitUntil(clawOn(63)==1);		   //<---
		wait1Msec(1000);				   //<---
		waitUntil(clawOff()==1);		   //<---
		//=======================================================================================================
		waitUntil(vexRT[Btn7D]==1); // Remote start for teleOp

		clearTimer(T1);
		while(time1[T1] < 10000){

			motor[leftMotor]  = (vexRT[Ch2] + vexRT[Ch1])/2;  // teleOp period
			motor[rightMotor] = (vexRT[Ch2] - vexRT[Ch1])/2;

		}
  	motor[leftMotor] = 0;
    motor[rightMotor] = 0;
    motor[armMotor] = 0;
    //=======================================================================================================
	}

}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
